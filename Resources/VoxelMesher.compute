#pragma kernel CSBuildFaces
#pragma kernel CSGreedyPosY
#pragma kernel CSGreedyNegY
#pragma kernel CSGreedyPosX
#pragma kernel CSGreedyNegX
#pragma kernel CSGreedyPosZ
#pragma kernel CSGreedyNegZ

StructuredBuffer<int> _BlockFaceTextures; // 6 face texture indices per block (top, bottom, north, south, east, west)
RWStructuredBuffer<uint> _Counters; // [0]=vertexCount, [1]=indexCount
RWStructuredBuffer<float> _Vertices; // PackedVertex stream: pos(3), normal(3), uv(2), ao(1), shadow(1), tangent(4), arraySlice(1), padding(1)
RWStructuredBuffer<uint> _Indices;
StructuredBuffer<uint> _Voxels; // uint per voxel: BlockId

int _ChunkSizeXZ;
int _ChunkSizeY;
int3 _ChunkCoord;
float3 _SunDir; // world-space, normalized
int _SunShadowSteps;
float _SunShadowStepLen;

static const uint FACE_NONE = 0u;
static const uint FACE_POS_X = 1u;
static const uint FACE_NEG_X = 2u;
static const uint FACE_POS_Y = 4u;
static const uint FACE_NEG_Y = 8u;
static const uint FACE_POS_Z = 16u;
static const uint FACE_NEG_Z = 32u;

uint FlattenIndex(uint x, uint y, uint z, uint width, uint height)
{
    return x + z * width + y * width * width;
}

bool IsSolid(uint id)
{
    return id != 0u;
}

uint GetVoxel(uint x, uint y, uint z)
{
    uint cs = (uint)_ChunkSizeXZ;
    uint cy = (uint)_ChunkSizeY;
    if (x >= cs || z >= cs || y >= cy) return 0u;
    uint idx = FlattenIndex(x, y, z, cs, cy);
    return _Voxels[idx] & 255u;
}

// Face direction constants
static const uint FACE_TOP = 0;    // +Y
static const uint FACE_BOTTOM = 1; // -Y
static const uint FACE_NORTH = 2;  // +Z
static const uint FACE_SOUTH = 3;  // -Z
static const uint FACE_EAST = 4;   // +X
static const uint FACE_WEST = 5;   // -X

uint GetFaceTextureIndex(uint blockId, uint faceDirection)
{
    if (blockId == 0) return 0; // Air has no texture
    
    uint baseIndex = blockId * 6; // 6 faces per block
    uint index = baseIndex + faceDirection;
    
    // Bounds check
    if (index >= 256 * 6) return 0;
    
    return (uint)_BlockFaceTextures[index];
}

float CornerAO(bool side1, bool side2, bool corner)
{
    // Classic Minecraft-like AO: 0..3 occluders â†’ 1..0.4
    int occluders = (side1?1:0) + (side2?1:0) + (corner?1:0);
    if (occluders == 3) return 0.4;
    if (occluders == 2) return 0.6;
    if (occluders == 1) return 0.8;
    return 1.0;
}

bool TraceVoxelSolid(float3 startWS)
{
    // startWS in voxel space units
    // march a few steps; if we hit a solid voxel return true
    float3 dir = normalize(_SunDir);
    float3 p = startWS;
    for (int i = 0; i < _SunShadowSteps; i++)
    {
        p += dir * _SunShadowStepLen;
        int ix = (int)floor(p.x + 0.5);
        int iy = (int)floor(p.y + 0.5);
        int iz = (int)floor(p.z + 0.5);
        if (ix < 0 || iz < 0 || iy < 0 || ix >= _ChunkSizeXZ || iz >= _ChunkSizeXZ || iy >= _ChunkSizeY) break;
        if (IsSolid(GetVoxel(ix, iy, iz))) return true;
    }
    return false;
}

void EmitQuad(float3 v0, float3 v1, float3 v2, float3 v3, float3 n, uint tileIndex, float4 ao, inout uint vOff, inout uint iOff, bool flip)
{
    // Tile-space UVs: 0..1, for texture arrays we use the tile index directly as array slice
    float2 uv0 = float2(0, 0);
    float2 uv1 = float2(1, 0);
    float2 uv2 = float2(1, 1);
    float2 uv3 = float2(0, 1);
    float arraySlice = (float)tileIndex;

    float3 pos[4] = { v0, v1, v2, v3 };
    float3 nor = n;
    float2 uvs[4] = { uv0, uv1, uv2, uv3 };
    float aof[4] = { ao.x, ao.y, ao.z, ao.w };
    // Tangent aligned with +U direction (v1 - v0)
    float3 tangent = normalize(v1 - v0);
    float tangentW = 1.0;

    [unroll]
    for (uint i = 0; i < 4; i++)
    {
        uint baseF = vOff * 16u;
        _Vertices[baseF + 0] = pos[i].x;
        _Vertices[baseF + 1] = pos[i].y;
        _Vertices[baseF + 2] = pos[i].z;
        _Vertices[baseF + 3] = nor.x;
        _Vertices[baseF + 4] = nor.y;
        _Vertices[baseF + 5] = nor.z;
        _Vertices[baseF + 6] = uvs[i].x;
        _Vertices[baseF + 7] = uvs[i].y;
        _Vertices[baseF + 8] = aof[i];
        // Trace a short ray from the vertex towards the sun; if blocked, darken
        float3 worldP = pos[i];
        bool blocked = TraceVoxelSolid(worldP + n * 0.5);
        _Vertices[baseF + 9] = blocked ? 0.4 : 1.0;
        _Vertices[baseF + 10] = tangent.x;
        _Vertices[baseF + 11] = tangent.y;
        _Vertices[baseF + 12] = tangent.z;
        _Vertices[baseF + 13] = tangentW;
        _Vertices[baseF + 14] = arraySlice;
        _Vertices[baseF + 15] = 0.0; // padding
        vOff++;
    }

    uint iBase = iOff;
    if (!flip)
    {
        _Indices[iBase + 0] = vOff - 4;
        _Indices[iBase + 1] = vOff - 3;
        _Indices[iBase + 2] = vOff - 2;
        _Indices[iBase + 3] = vOff - 4;
        _Indices[iBase + 4] = vOff - 2;
        _Indices[iBase + 5] = vOff - 1;
    }
    else
    {
        _Indices[iBase + 0] = vOff - 4;
        _Indices[iBase + 1] = vOff - 2;
        _Indices[iBase + 2] = vOff - 3;
        _Indices[iBase + 3] = vOff - 4;
        _Indices[iBase + 4] = vOff - 1;
        _Indices[iBase + 5] = vOff - 2;
    }
    iOff += 6;
}

// Greedy variant: tile-space UVs span 0..w and 0..h, plus array slice index
void EmitQuadGreedy(float3 v0, float3 v1, float3 v2, float3 v3, float3 n, uint arraySlice, uint w, uint h, float4 ao, inout uint vOff, inout uint iOff, bool flip)
{
    // For proper texture tiling, we need consistent UV orientation across all face types
    // The issue is that different face orientations have different axis mappings
    float2 uv0, uv1, uv2, uv3;
    
    if (abs(n.y) > 0.5) {
        // Top/bottom faces (+Y/-Y): w=X extent, h=Z extent
        uv0 = float2(0, 0);
        uv1 = float2((float)w, 0);
        uv2 = float2((float)w, (float)h);
        uv3 = float2(0, (float)h);
    } else {
        // Side faces: For consistent texture orientation, we may need to swap dimensions
        // This ensures that vertical faces have proper texture alignment
        uv0 = float2(0, 0);
        uv1 = float2((float)w, 0);
        uv2 = float2((float)w, (float)h);
        uv3 = float2(0, (float)h);
    }

    float3 pos[4] = { v0, v1, v2, v3 };
    float3 nor = n;
    float2 uvs[4] = { uv0, uv1, uv2, uv3 };
    float aof[4] = { ao.x, ao.y, ao.z, ao.w };

    float3 tangent = normalize(v1 - v0);
    float tangentW = 1.0;

    [unroll]
    for (uint i = 0; i < 4; i++)
    {
        uint baseF = vOff * 16u;
        _Vertices[baseF + 0] = pos[i].x;
        _Vertices[baseF + 1] = pos[i].y;
        _Vertices[baseF + 2] = pos[i].z;
        _Vertices[baseF + 3] = nor.x;
        _Vertices[baseF + 4] = nor.y;
        _Vertices[baseF + 5] = nor.z;
        _Vertices[baseF + 6] = uvs[i].x;
        _Vertices[baseF + 7] = uvs[i].y;
        _Vertices[baseF + 8] = aof[i];
        _Vertices[baseF + 9] = 1.0;
        _Vertices[baseF + 10] = tangent.x;
        _Vertices[baseF + 11] = tangent.y;
        _Vertices[baseF + 12] = tangent.z;
        _Vertices[baseF + 13] = tangentW;
        _Vertices[baseF + 14] = (float)arraySlice;
        _Vertices[baseF + 15] = 0.0; // padding
        vOff++;
    }

    uint iBase = iOff;
    if (!flip)
    {
        _Indices[iBase + 0] = vOff - 4;
        _Indices[iBase + 1] = vOff - 3;
        _Indices[iBase + 2] = vOff - 2;
        _Indices[iBase + 3] = vOff - 4;
        _Indices[iBase + 4] = vOff - 2;
        _Indices[iBase + 5] = vOff - 1;
    }
    else
    {
        _Indices[iBase + 0] = vOff - 4;
        _Indices[iBase + 1] = vOff - 2;
        _Indices[iBase + 2] = vOff - 3;
        _Indices[iBase + 3] = vOff - 4;
        _Indices[iBase + 4] = vOff - 1;
        _Indices[iBase + 5] = vOff - 2;
    }
    iOff += 6;
}

groupshared uint gMask[4096];
groupshared uint gVisited[4096];

// Full 2D greedy: merge rectangles (width x height) of identical tile values
void GreedyRects(uint planeW, uint planeH, float3 baseOrigin, float3 uStep, float3 vStep, float3 normal, bool flip)
{
    for (uint i = 0; i < planeH; i++)
    {
        for (uint j = 0; j < planeW; j++)
        {
            uint idx = i * planeW + j;
            if (gVisited[idx] != 0) continue;
            uint val = gMask[idx];
            if (val == 0) { gVisited[idx] = 1; continue; }
            // Expand width first
            uint w = 1;
            while ((j + w) < planeW)
            {
                uint nextIdx = i * planeW + (j + w);
                if (gVisited[nextIdx] != 0 || gMask[nextIdx] != val) break;
                w++;
            }
            // Then expand height while all rows match the run
            uint h = 1;
            bool canGrow = true;
            while (canGrow && (i + h) < planeH)
            {
                for (uint x = 0; x < w; x++)
                {
                    uint checkIdx = (i + h) * planeW + (j + x);
                    if (gVisited[checkIdx] != 0 || gMask[checkIdx] != val)
                    {
                        canGrow = false;
                        break;
                    }
                }
                if (canGrow) h++;
            }

            float3 v0 = baseOrigin + uStep * j      + vStep * i;
            float3 v1 = v0         + uStep * w;
            float3 v3 = v0         + vStep * h;
            float3 v2 = v3         + uStep * w;

            uint vStart; InterlockedAdd(_Counters[0], 4, vStart);
            uint iStart; InterlockedAdd(_Counters[1], 6, iStart);
            float4 ao = float4(1,1,1,1);
            uint arraySlice = val; // Use texture index directly as array slice
            EmitQuadGreedy(v0, v1, v2, v3, normal, arraySlice, w, h, ao, vStart, iStart, flip);

            // Mark visited rectangle
            for (uint yy = 0; yy < h; yy++)
            {
                uint row = (i + yy) * planeW + j;
                for (uint xx = 0; xx < w; xx++) gVisited[row + xx] = 1;
            }
            j += (w - 1);
        }
    }
}

[numthreads(1,1,1)]
void CSGreedyPosY(uint3 gid : SV_DispatchThreadID)
{
    uint y = gid.x;
    uint cs = (uint)_ChunkSizeXZ;
    uint cy = (uint)_ChunkSizeY;
    if (y >= cy) return;
    // Build mask for +Y faces on XZ plane at this y
    uint planeW = cs;
    uint planeH = cs;
    for (uint z = 0; z < planeH; z++)
    {
        for (uint x = 0; x < planeW; x++)
        {
            uint id = GetVoxel(x, y, z);
            uint visible = !IsSolid(GetVoxel(x, y + 1u, z));
            uint tile = visible && IsSolid(id) ? GetFaceTextureIndex(id, FACE_TOP) : 0u;
            gMask[z * planeW + x] = tile;
            gVisited[z * planeW + x] = 0u;
        }
    }
    float3 baseOrigin = float3(0, y + 1u, 0);
    // Top (+Y) faces outward; use flipped according to EmitQuad convention
    GreedyRects(planeW, planeH, baseOrigin, float3(1,0,0), float3(0,0,1), float3(0,1,0), true);
}

[numthreads(1,1,1)]
void CSGreedyNegY(uint3 gid : SV_DispatchThreadID)
{
    uint y = gid.x;
    uint cs = (uint)_ChunkSizeXZ;
    uint cy = (uint)_ChunkSizeY;
    if (y >= cy) return;
    uint planeW = cs;
    uint planeH = cs;
    for (uint z = 0; z < planeH; z++)
    {
        for (uint x = 0; x < planeW; x++)
        {
            uint id = GetVoxel(x, y, z);
            uint visible = (y == 0u) || !IsSolid(GetVoxel(x, y - 1u, z));
            uint tile = visible && IsSolid(id) ? GetFaceTextureIndex(id, FACE_BOTTOM) : 0u;
            gMask[z * planeW + x] = tile;
            gVisited[z * planeW + x] = 0u;
        }
    }
    float3 baseOrigin = float3(0, y, 0);
    GreedyRects(planeW, planeH, baseOrigin, float3(1,0,0), float3(0,0,1), float3(0,-1,0), false);
}

[numthreads(1,1,1)]
void CSGreedyPosX(uint3 gid : SV_DispatchThreadID)
{
    uint x = gid.x;
    uint cs = (uint)_ChunkSizeXZ;
    uint cy = (uint)_ChunkSizeY;
    if (x >= cs) return;
    uint planeW = cs; // along Z
    uint planeH = cy;  // along Y
    for (uint y = 0; y < planeH; y++)
    {
        for (uint z = 0; z < planeW; z++)
        {
            uint id = GetVoxel(x, y, z);
            uint visible = !IsSolid(GetVoxel(x + 1u, y, z));
            uint tile = visible && IsSolid(id) ? GetFaceTextureIndex(id, FACE_EAST) : 0u;
            gMask[y * planeW + z] = tile;
            gVisited[y * planeW + z] = 0u;
        }
    }
    float3 baseOrigin = float3(x + 1u, 0, 0);
    GreedyRects(planeW, planeH, baseOrigin, float3(0,0,1), float3(0,1,0), float3(1,0,0), true);
}

[numthreads(1,1,1)]
void CSGreedyNegX(uint3 gid : SV_DispatchThreadID)
{
    uint x = gid.x;
    uint cs = (uint)_ChunkSizeXZ;
    uint cy = (uint)_ChunkSizeY;
    if (x >= cs) return;
    uint planeW = cs; // along Z
    uint planeH = cy;  // along Y
    for (uint y = 0; y < planeH; y++)
    {
        for (uint z = 0; z < planeW; z++)
        {
            uint id = GetVoxel(x, y, z);
            uint visible = (x == 0u) || !IsSolid(GetVoxel(x - 1u, y, z));
            uint tile = visible && IsSolid(id) ? GetFaceTextureIndex(id, FACE_WEST) : 0u;
            gMask[y * planeW + z] = tile;
            gVisited[y * planeW + z] = 0u;
        }
    }
    float3 baseOrigin = float3(x, 0, 0);
    GreedyRects(planeW, planeH, baseOrigin, float3(0,0,1), float3(0,1,0), float3(-1,0,0), false);
}

[numthreads(1,1,1)]
void CSGreedyPosZ(uint3 gid : SV_DispatchThreadID)
{
    uint z = gid.x;
    uint cs = (uint)_ChunkSizeXZ;
    uint cy = (uint)_ChunkSizeY;
    if (z >= cs) return;
    uint planeW = cs; // along X
    uint planeH = cy;  // along Y
    for (uint y = 0; y < planeH; y++)
    {
        for (uint x = 0; x < planeW; x++)
        {
            uint id = GetVoxel(x, y, z);
            uint visible = !IsSolid(GetVoxel(x, y, z + 1u));
            uint tile = visible && IsSolid(id) ? GetFaceTextureIndex(id, FACE_NORTH) : 0u;
            gMask[y * planeW + x] = tile;
            gVisited[y * planeW + x] = 0u;
        }
    }
    float3 baseOrigin = float3(0, 0, z + 1u);
    GreedyRects(planeW, planeH, baseOrigin, float3(1,0,0), float3(0,1,0), float3(0,0,1), false);
}

[numthreads(1,1,1)]
void CSGreedyNegZ(uint3 gid : SV_DispatchThreadID)
{
    uint z = gid.x;
    uint cs = (uint)_ChunkSizeXZ;
    uint cy = (uint)_ChunkSizeY;
    if (z >= cs) return;
    uint planeW = cs; // along X
    uint planeH = cy;  // along Y
    for (uint y = 0; y < planeH; y++)
    {
        for (uint x = 0; x < planeW; x++)
        {
            uint id = GetVoxel(x, y, z);
            uint visible = (z == 0u) || !IsSolid(GetVoxel(x, y, z - 1u));
            uint tile = visible && IsSolid(id) ? GetFaceTextureIndex(id, FACE_SOUTH) : 0u;
            gMask[y * planeW + x] = tile;
            gVisited[y * planeW + x] = 0u;
        }
    }
    float3 baseOrigin = float3(0, 0, z);
    GreedyRects(planeW, planeH, baseOrigin, float3(1,0,0), float3(0,1,0), float3(0,0,-1), true);
}

[numthreads(8,8,8)]
void CSBuildFaces(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _ChunkSizeXZ || id.z >= _ChunkSizeXZ || id.y >= _ChunkSizeY) return;
    uint block = GetVoxel(id.x, id.y, id.z);
    if (!IsSolid(block)) return;

    bool posX = !IsSolid(GetVoxel(id.x + 1, id.y, id.z));
    bool negX = (id.x == 0) || !IsSolid(GetVoxel(id.x - 1, id.y, id.z));
    bool posY = !IsSolid(GetVoxel(id.x, id.y + 1, id.z));
    bool negY = (id.y == 0) || !IsSolid(GetVoxel(id.x, id.y - 1, id.z));
    bool posZ = !IsSolid(GetVoxel(id.x, id.y, id.z + 1));
    bool negZ = (id.z == 0) || !IsSolid(GetVoxel(id.x, id.y, id.z - 1));

    uint visible = (posX?1u:0u) | (negX?2u:0u) | (posY?4u:0u) | (negY?8u:0u) | (posZ?16u:0u) | (negZ?32u:0u);
    if (visible == 0u) return;

    uint faceCount = 0;
    [unroll]
    for (int i = 0; i < 6; i++)
    {
        faceCount += (visible & (1u << i)) != 0 ? 1u : 0u;
    }

    // Reserve maximum needed per voxel
    uint vStart;
    InterlockedAdd(_Counters[0], faceCount * 4u, vStart);
    uint iStart;
    InterlockedAdd(_Counters[1], faceCount * 6u, iStart);

    float3 base = float3(id.x, id.y, id.z);
    // Get face-specific texture indices
    // We'll use variables for each face type

    uint vOff = vStart;
    uint iOff = iStart;

    if (posX)
    {
        // AO sampling on x+1 plane
        bool yNeg = IsSolid(GetVoxel(id.x + 1, id.y - 1, id.z));
        bool yPos = IsSolid(GetVoxel(id.x + 1, id.y + 1, id.z));
        bool zNeg = IsSolid(GetVoxel(id.x + 1, id.y, id.z - 1));
        bool zPos = IsSolid(GetVoxel(id.x + 1, id.y, id.z + 1));
        float4 ao = float4(
            CornerAO(yNeg, zNeg, IsSolid(GetVoxel(id.x + 1, id.y - 1, id.z - 1))),
            CornerAO(yNeg, zPos, IsSolid(GetVoxel(id.x + 1, id.y - 1, id.z + 1))),
            CornerAO(yPos, zPos, IsSolid(GetVoxel(id.x + 1, id.y + 1, id.z + 1))),
            CornerAO(yPos, zNeg, IsSolid(GetVoxel(id.x + 1, id.y + 1, id.z - 1)))
        );
        EmitQuad(base + float3(1,0,0), base + float3(1,0,1), base + float3(1,1,1), base + float3(1,1,0), float3(1,0,0), GetFaceTextureIndex(block, FACE_EAST), ao, vOff, iOff, true);
    }
    if (negX)
    {
        bool yNeg = IsSolid(GetVoxel(id.x - 1, id.y - 1, id.z));
        bool yPos = IsSolid(GetVoxel(id.x - 1, id.y + 1, id.z));
        bool zNeg = IsSolid(GetVoxel(id.x - 1, id.y, id.z - 1));
        bool zPos = IsSolid(GetVoxel(id.x - 1, id.y, id.z + 1));
        float4 ao = float4(
            CornerAO(yNeg, zPos, IsSolid(GetVoxel(id.x - 1, id.y - 1, id.z + 1))),
            CornerAO(yNeg, zNeg, IsSolid(GetVoxel(id.x - 1, id.y - 1, id.z - 1))),
            CornerAO(yPos, zNeg, IsSolid(GetVoxel(id.x - 1, id.y + 1, id.z - 1))),
            CornerAO(yPos, zPos, IsSolid(GetVoxel(id.x - 1, id.y + 1, id.z + 1)))
        );
        EmitQuad(base + float3(0,0,1), base + float3(0,0,0), base + float3(0,1,0), base + float3(0,1,1), float3(-1,0,0), GetFaceTextureIndex(block, FACE_WEST), ao, vOff, iOff, true);
    }
    if (posY)
    {
        bool xNeg = IsSolid(GetVoxel(id.x - 1, id.y + 1, id.z));
        bool xPos = IsSolid(GetVoxel(id.x + 1, id.y + 1, id.z));
        bool zNeg = IsSolid(GetVoxel(id.x, id.y + 1, id.z - 1));
        bool zPos = IsSolid(GetVoxel(id.x, id.y + 1, id.z + 1));
        float4 ao = float4(
            CornerAO(xNeg, zPos, IsSolid(GetVoxel(id.x - 1, id.y + 1, id.z + 1))),
            CornerAO(xPos, zPos, IsSolid(GetVoxel(id.x + 1, id.y + 1, id.z + 1))),
            CornerAO(xPos, zNeg, IsSolid(GetVoxel(id.x + 1, id.y + 1, id.z - 1))),
            CornerAO(xNeg, zNeg, IsSolid(GetVoxel(id.x - 1, id.y + 1, id.z - 1)))
        );
        EmitQuad(base + float3(0,1,1), base + float3(1,1,1), base + float3(1,1,0), base + float3(0,1,0), float3(0,1,0), GetFaceTextureIndex(block, FACE_TOP), ao, vOff, iOff, false);
    }
    if (negY)
    {
        bool xNeg = IsSolid(GetVoxel(id.x - 1, id.y - 1, id.z));
        bool xPos = IsSolid(GetVoxel(id.x + 1, id.y - 1, id.z));
        bool zNeg = IsSolid(GetVoxel(id.x, id.y - 1, id.z - 1));
        bool zPos = IsSolid(GetVoxel(id.x, id.y - 1, id.z + 1));
        float4 ao = float4(
            CornerAO(xNeg, zNeg, IsSolid(GetVoxel(id.x - 1, id.y - 1, id.z - 1))),
            CornerAO(xPos, zNeg, IsSolid(GetVoxel(id.x + 1, id.y - 1, id.z - 1))),
            CornerAO(xPos, zPos, IsSolid(GetVoxel(id.x + 1, id.y - 1, id.z + 1))),
            CornerAO(xNeg, zPos, IsSolid(GetVoxel(id.x - 1, id.y - 1, id.z + 1)))
        );
        EmitQuad(base + float3(0,0,0), base + float3(1,0,0), base + float3(1,0,1), base + float3(0,0,1), float3(0,-1,0), GetFaceTextureIndex(block, FACE_BOTTOM), ao, vOff, iOff, false);
    }
    if (posZ)
    {
        bool xNeg = IsSolid(GetVoxel(id.x - 1, id.y, id.z + 1));
        bool xPos = IsSolid(GetVoxel(id.x + 1, id.y, id.z + 1));
        bool yNeg = IsSolid(GetVoxel(id.x, id.y - 1, id.z + 1));
        bool yPos = IsSolid(GetVoxel(id.x, id.y + 1, id.z + 1));
        float4 ao = float4(
            CornerAO(xNeg, yNeg, IsSolid(GetVoxel(id.x - 1, id.y - 1, id.z + 1))),
            CornerAO(xPos, yNeg, IsSolid(GetVoxel(id.x + 1, id.y - 1, id.z + 1))),
            CornerAO(xPos, yPos, IsSolid(GetVoxel(id.x + 1, id.y + 1, id.z + 1))),
            CornerAO(xNeg, yPos, IsSolid(GetVoxel(id.x - 1, id.y + 1, id.z + 1)))
        );
        EmitQuad(base + float3(0,0,1), base + float3(1,0,1), base + float3(1,1,1), base + float3(0,1,1), float3(0,0,1), GetFaceTextureIndex(block, FACE_NORTH), ao, vOff, iOff, false);
    }
    if (negZ)
    {
        bool xNeg = IsSolid(GetVoxel(id.x - 1, id.y, id.z - 1));
        bool xPos = IsSolid(GetVoxel(id.x + 1, id.y, id.z - 1));
        bool yNeg = IsSolid(GetVoxel(id.x, id.y - 1, id.z - 1));
        bool yPos = IsSolid(GetVoxel(id.x, id.y + 1, id.z - 1));
        float4 ao = float4(
            CornerAO(xPos, yNeg, IsSolid(GetVoxel(id.x + 1, id.y - 1, id.z - 1))),
            CornerAO(xNeg, yNeg, IsSolid(GetVoxel(id.x - 1, id.y - 1, id.z - 1))),
            CornerAO(xNeg, yPos, IsSolid(GetVoxel(id.x - 1, id.y + 1, id.z - 1))),
            CornerAO(xPos, yPos, IsSolid(GetVoxel(id.x + 1, id.y + 1, id.z - 1)))
        );
        // CCW when viewed from -Z
        EmitQuad(base + float3(1,0,0), base + float3(0,0,0), base + float3(0,1,0), base + float3(1,1,0), float3(0,0,-1), GetFaceTextureIndex(block, FACE_SOUTH), ao, vOff, iOff, false);
    }
}


//#pragma enable_d3d11_debug_symbols
#pragma kernel CSBuildFaces

StructuredBuffer<uint3> _BlockUvTriplets; // uv tile indices per block: top, side, bottom
RWStructuredBuffer<uint> _Counters; // [0]=vertexCount, [1]=indexCount
RWStructuredBuffer<float> _Vertices; // PackedVertex stream: pos(3), normal(3), uv(2)
RWStructuredBuffer<uint> _Indices;
StructuredBuffer<uint> _Voxels; // uint per voxel: BlockId

int _ChunkSizeXZ;
int _ChunkSizeY;
int _AtlasTilesPerRow;
int3 _ChunkCoord;

static const uint FACE_NONE = 0u;
static const uint FACE_POS_X = 1u;
static const uint FACE_NEG_X = 2u;
static const uint FACE_POS_Y = 4u;
static const uint FACE_NEG_Y = 8u;
static const uint FACE_POS_Z = 16u;
static const uint FACE_NEG_Z = 32u;

// Helpers
uint FlattenIndex(uint x, uint y, uint z, uint width, uint height)
{
    return x + z * width + y * width * width;
}

uint3 UnflattenIndex(uint idx, uint width, uint height)
{
    uint layer = width * width;
    uint y = idx / layer;
    uint r = idx - y * layer;
    uint z = r / width;
    uint x = r - z * width;
    return uint3(x, y, z);
}

bool IsSolid(uint id)
{
    return id != 0u;
}

uint GetVoxel(uint x, uint y, uint z)
{
    if (x >= _ChunkSizeXZ || z >= _ChunkSizeXZ || y >= _ChunkSizeY) return 0u;
    uint idx = FlattenIndex(x, y, z, _ChunkSizeXZ, _ChunkSizeY);
    return _Voxels[idx] & 255u;
}

// Write a quad into vertex/index streams at offsets
void EmitQuad(float3 v0, float3 v1, float3 v2, float3 v3, float3 n, uint tileIndex, inout uint vOff, inout uint iOff)
{
    // Compute base UVs for tileIndex
    uint tileX = tileIndex % _AtlasTilesPerRow;
    uint tileY = tileIndex / _AtlasTilesPerRow;
    float inv = 1.0 / _AtlasTilesPerRow;
    float2 uv0 = float2(tileX * inv, tileY * inv);
    float2 uv1 = uv0 + float2(inv, 0);
    float2 uv2 = uv0 + float2(inv, inv);
    float2 uv3 = uv0 + float2(0, inv);

    // Write vertices: 8 floats each
    float3 pos[4] = { v0, v1, v2, v3 };
    float3 nor = n;
    float2 uvs[4] = { uv0, uv1, uv2, uv3 };
    [unroll]
    for (uint i = 0; i < 4; i++)
    {
        uint baseF = vOff * 8u;
        _Vertices[baseF + 0] = pos[i].x;
        _Vertices[baseF + 1] = pos[i].y;
        _Vertices[baseF + 2] = pos[i].z;
        _Vertices[baseF + 3] = nor.x;
        _Vertices[baseF + 4] = nor.y;
        _Vertices[baseF + 5] = nor.z;
        _Vertices[baseF + 6] = uvs[i].x;
        _Vertices[baseF + 7] = uvs[i].y;
        vOff++;
    }

    uint iBase = iOff;
    _Indices[iBase + 0] = vOff - 4;
    _Indices[iBase + 1] = vOff - 3;
    _Indices[iBase + 2] = vOff - 2;
    _Indices[iBase + 3] = vOff - 4;
    _Indices[iBase + 4] = vOff - 2;
    _Indices[iBase + 5] = vOff - 1;
    iOff += 6;
}

// Build faces per-voxel with local greedy culling (neighbor check)
[numthreads(8,8,8)]
void CSBuildFaces(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _ChunkSizeXZ || id.z >= _ChunkSizeXZ || id.y >= _ChunkSizeY) return;
    uint block = GetVoxel(id.x, id.y, id.z);
    if (!IsSolid(block)) return;

    // Neighbor checks
    bool posX = !IsSolid(GetVoxel(id.x + 1, id.y, id.z));
    bool negX = (id.x == 0) || !IsSolid(GetVoxel(id.x - 1, id.y, id.z));
    bool posY = !IsSolid(GetVoxel(id.x, id.y + 1, id.z));
    bool negY = (id.y == 0) || !IsSolid(GetVoxel(id.x, id.y - 1, id.z));
    bool posZ = !IsSolid(GetVoxel(id.x, id.y, id.z + 1));
    bool negZ = (id.z == 0) || !IsSolid(GetVoxel(id.x, id.y, id.z - 1));

    uint visible = (posX?FACE_POS_X:0u) | (negX?FACE_NEG_X:0u) | (posY?FACE_POS_Y:0u) | (negY?FACE_NEG_Y:0u) | (posZ?FACE_POS_Z:0u) | (negZ?FACE_NEG_Z:0u);
    if (visible == 0u) return;

    // Count faces for this voxel
    uint faceCount = 0;
    [unroll]
    for (int i = 0; i < 6; i++)
    {
        faceCount += (visible & (1u << i)) != 0 ? 1u : 0u;
    }

    // Atomically reserve space in global streams
    uint vStart;
    InterlockedAdd(_Counters[0], faceCount * 4u, vStart);
    uint iStart;
    InterlockedAdd(_Counters[1], faceCount * 6u, iStart);

    float3 base = float3(id.x, id.y, id.z);
    uint3 tiles = _BlockUvTriplets[block];

    uint vOff = vStart;
    uint iOff = iStart;

    if (posX)
    {
        EmitQuad(base + float3(1,0,0), base + float3(1,0,1), base + float3(1,1,1), base + float3(1,1,0), float3(1,0,0), tiles.y, vOff, iOff);
    }
    if (negX)
    {
        EmitQuad(base + float3(0,0,1), base + float3(0,0,0), base + float3(0,1,0), base + float3(0,1,1), float3(-1,0,0), tiles.y, vOff, iOff);
    }
    if (posY)
    {
        EmitQuad(base + float3(0,1,1), base + float3(1,1,1), base + float3(1,1,0), base + float3(0,1,0), float3(0,1,0), tiles.x, vOff, iOff);
    }
    if (negY)
    {
        EmitQuad(base + float3(0,0,0), base + float3(1,0,0), base + float3(1,0,1), base + float3(0,0,1), float3(0,-1,0), tiles.z, vOff, iOff);
    }
    if (posZ)
    {
        EmitQuad(base + float3(0,0,1), base + float3(1,0,1), base + float3(1,1,1), base + float3(0,1,1), float3(0,0,1), tiles.y, vOff, iOff);
    }
    if (negZ)
    {
        EmitQuad(base + float3(1,0,0), base + float3(0,0,0), base + float3(0,1,0), base + float3(1,1,0), float3(0,0,-1), tiles.y, vOff, iOff);
    }
}


